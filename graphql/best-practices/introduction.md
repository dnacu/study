# Introduction

GraphQL 명세서에서는 네트워크, 인증, 페이지네이션 처리 등의 API 사용에서의 중요한 문제에 대하여 의도적으로 다루지 않는다. 해결책이 없는 것은 아니나, 이러한 문제들은 GraphQL과 연관이 없다.

## HTTP

GraphQL은 일반적으로 서비스의 모든 기능을 하나의 endpoint를 통해 제공한다. URL에 따라 단일 리소스를 표현하고자 하는 REST API와는 대조적이다.

> GraphQL은 이들과 함께 사용될 수 있으나, GraphiQL등의 지원도구를 사용하기 힘들어질 수 있다.

## JSON (with GZIP)

GraphQL서비스는 일반적으로 JSON형식으로 응답하지만, 필수는 아니다. JSON은 대부분 텍스트이기 때문에 `GZIP` 으로 굉장히 잘 압축된다.

production 레벨의 GraphQL 서비스는 `GZIP` 을 가용케 하고, 클라이언트 측에서 아래 헤더를 추가할 것을 권장한다.

```
Accept-Encoding: gzip
```

JSON 형식은 개발자에게 굉장히 친숙하며, GraphQL syntax도 이에 영감을 받았다.

> GZIP을 사용함으로써 응답의 압축을 통해 HTTP 통신 리소스를 줄일 수 있다. 하지만 클라이언트 측에서 CPU 를 활용하여 해당 압축을 해제하기 때문에 성능이 낮은 기기를 사용하는 사용자에게는 더 나빠질 수 있다.

## Versioning

GraphQL 서비스도 REST API와 마찬가지로 버전 변경에 대해 막을 수 없다. 하지만 GraphQL에서는 지속적 업데이트를 위한 도구를 제공하여 버전관리를 피하고자 한다.

대부분의 API는 버전관리가 필요하다. API endpoint에서 반환되는 데이터에 대한 변경이 있을 때, 연쇄적으로 다른 API들까지도 변경될 수 있다. 이러한 큰 변경사항에는 새 버전이 요구되며, API를 이해하기 쉽고 유지보수할 수 있는 버전을 자주 출시하고 업데이트 버전을 사용하는 것이 좋다.

하지만 GraphQL은 명시적으로 요청된 데이터에 대해서만 반환하므로 새로운 타입 및 필드를 통해 기능에 대한 추가가 비교적 용이하기 때문에 이를 쉽게 해준다.

## Nullability

`null` 을 판단하는 대부분의 타입 시스템에서는, 일반 타입과 해당 타입의 _nullable_ 버전을 제공하며, 명시적으로 선언하지 않는한 기본적으로 `null` 을 포함하지 않는다.

하지만 GraphQL 타입 시스템에서는 모든 필드가 기본적으로 *nullable*한데, 이는 db, 네트워크, 백엔드서비스에서 많은 일이 발생할 수 있기 떄문이다.

모든 필드를 *nullable*로 설정하면, 요청이 완전히 실패하지 않고 해당 필드가 `null` 로 반환된다. GraphQL은 `non-null` 타입을 제공하며, 요청 시 필드가 절대 `null`을 반환하지 않도록 보장한다. 만약 해당 필드에서 오류가 발생하면, 상위 필드가 대신 `null` 값을 가지게 된다.
